---
import Layout from "../../layouts/Layout.astro";
import { getEntry, getCollection } from "astro:content";

const dateTimeFormat = new Intl.DateTimeFormat("nl-NL");
const pluralRules = new Intl.PluralRules("en-US");

export async function getStaticPaths() {
  const products = await getCollection("products");
  return products.map((product) => ({
    params: { id: product.id },
  }));
}

const { id } = Astro.params;
if (id === undefined) {
  throw new Error("No product ID provided");
}

const product = await getEntry("products", id);
if (product === undefined) {
  throw new Error(`Product with ID ${id} not found`);
}

const { firstAppearance, absenceRanges } = product.data;

const inStock =
  absenceRanges.at(-1)?.end === undefined ||
  absenceRanges.at(-1)?.end !== new Date().toISOString().split("T")[0];

const timelineSegments = [];
let cursor = firstAppearance;
for (const absence of absenceRanges) {
  timelineSegments.push({
    start: new Date(cursor),
    end: yesterday(absence.start),
    status: "present",
  });
  if (absence.end) {
    timelineSegments.push({
      start: new Date(absence.start),
      end: yesterday(absence.end),
      status: "absent",
    });
    cursor = absence.end;
  } else {
    timelineSegments.push({
      start: new Date(absence.start),
      end: new Date(),
      status: "absent",
    });
    break;
  }
}
if (inStock) {
  timelineSegments.push({
    start: new Date(cursor),
    end: new Date(),
    status: "present",
  });
}

function yesterday(dateStr: string) {
  const date = new Date(dateStr);
  date.setDate(date.getDate() - 1);
  return date;
}

function countDays(range: { start: Date; end: Date; status: string }) {
  const endInclusive = new Date(range.end);
  endInclusive.setDate(endInclusive.getDate() + 1);
  return Math.ceil(
    (endInclusive.getTime() - range.start.getTime()) / (1000 * 60 * 60 * 24)
  );
}

function detectRecurringPattern(
  absenceRanges: Array<{ start: string; end?: string | undefined }>
) {
  // Check for regular intervals between absences
  if (absenceRanges.length >= 3) {
    const intervals = [];
    for (let i = 1; i < absenceRanges.length; i++) {
      const prevStart = new Date(absenceRanges[i - 1].start);
      const currentStart = new Date(absenceRanges[i].start);
      const daysDiff = Math.ceil(
        (currentStart.getTime() - prevStart.getTime()) / (1000 * 60 * 60 * 24)
      );
      intervals.push(daysDiff);
    }

    const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
    const variance =
      intervals.reduce(
        (acc, interval) => acc + Math.pow(interval - avgInterval, 2),
        0
      ) / intervals.length;
    const stdDev = Math.sqrt(variance);

    // If standard deviation is less than 20% of the average, consider it regular
    if (stdDev < avgInterval * 0.2 && avgInterval > 30) {
      return {
        type: "regular",
        averageInterval: Math.round(avgInterval),
        consistency: Math.round((1 - stdDev / avgInterval) * 100),
      };
    }
  }

  return null;
}

const recurringPattern = detectRecurringPattern(absenceRanges);
---

<script>
  import "@weblogin/trendchart-elements";
</script>

<Layout>
  <main>
    <wa-breadcrumb>
      <wa-breadcrumb-item href="/">
        <wa-icon slot="start" name="house"></wa-icon>
        Home
      </wa-breadcrumb-item>
      <wa-breadcrumb-item>{id}</wa-breadcrumb-item>
    </wa-breadcrumb>

    <hgroup>
      <h1>{id}</h1>
      {
        inStock ? (
          <wa-tag variant="success">In stock!</wa-tag>
        ) : (
          <wa-tag variant="danger">Out of stock</wa-tag>
        )
      }
      <!-- if in stock, <HowMuchTimeLeft /> until out of stock again -->
    </hgroup>

    <wa-card>
      <h2 slot="header">
        <wa-icon name="boxes-stacked" variant="solid"></wa-icon>
        Availability
      </h2>
      <div class="wa-split">
        <date datetime={firstAppearance}
          >{dateTimeFormat.format(new Date(firstAppearance))}</date
        >
        <date datetime={new Date(timelineSegments.at(-1)?.end || new Date())}
          >{
            dateTimeFormat.format(
              new Date(timelineSegments.at(-1)?.end || new Date())
            )
          }</date
        >
      </div>
      <tc-stack
        class="chart"
        horizontal
        values={JSON.stringify(timelineSegments.map(countDays))}
        labels={JSON.stringify(
          timelineSegments.map((r) =>
            r.status === "present"
              ? `In stock: ${dateTimeFormat.formatRange(new Date(r.start), new Date(r.end))} (${countDays(r)} ${pluralRules.select(countDays(r)) === "one" ? "day" : "days"})`
              : `Out of stock: ${dateTimeFormat.formatRange(new Date(r.start), new Date(r.end))} (${countDays(r)} ${pluralRules.select(countDays(r)) === "one" ? "day" : "days"})`
          )
        )}
        tooltip-format="@L"
        radius="20"
        gap="3"
        style={`width: 100%; ${timelineSegments.map((_, i) => `--shape-color-${i + 1}: var(${i % 2 === 0 ? "--wa-color-green-50" : "--wa-color-red-50"});`).join(" ")}`}
      ></tc-stack>

      <p slot="footer">
        {
          recurringPattern ? (
            <span>
              This product tends to appear in stock every
              <strong> {recurringPattern.averageInterval} days</strong> on
              average
            </span>
          ) : (
            <span>
              This product has been out of stock
              <strong>
                {absenceRanges.length}{" "}
                {
                  { one: "time", other: "times" }[
                    pluralRules.select(absenceRanges.length) as "one" | "other"
                  ]
                }
              </strong>{" "}
              since it first appeared.
            </span>
          )
        }
      </p>
    </wa-card>
  </main>

  <!-- <PriceGraph /> -->
</Layout>

<style>
  main {
    margin-block-start: var(--wa-space-2xl);
    display: grid;
    gap: var(--wa-space-3xl);
  }

  wa-card h2 {
    margin-block: var(--wa-space-s);
  }
</style>
